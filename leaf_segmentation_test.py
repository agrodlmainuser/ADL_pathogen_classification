# -*- coding: utf-8 -*-
"""Leaf_Segmentation_Test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LqhYbu0W6OO9ElJLqGgfCackpjlrer5A
"""

from tensorflow.keras.utils import normalize
import os
import cv2
from PIL import Image
import numpy as np
from matplotlib import pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.optimizers import Adam
import glob
from skimage import io
from google.colab.patches import cv2_imshow
from tensorflow.keras.metrics import MeanIoU
from sklearn.metrics import confusion_matrix

#Load previously saved model
from keras.models import load_model
model = load_model("/content/drive/MyDrive/Agroml/Tomer/Leaf_segmentation/leaf_segmentation_v2.h5", compile=False)

# Load Image as original and greyscale
img = cv2.imread("/content/6.JPG")
grey = cv2.imread("/content/6.JPG", 0)

# Convert to numpy array anf fit dimensions to prediction
image_asnumpy = np.array(grey)
image = np.expand_dims(image_asnumpy, axis=2)

# Check dimensions
image.shape

# Plotting images
plt.figure(figsize=(16, 8))

plt.subplot(231)
plt.title('Greyscale Image')
plt.imshow(image[:,:,0], cmap='gray')

plt.subplot(232)
plt.title('Original Image')
plt.imshow(img)

# Image further tranformation 

image = np.expand_dims(image, axis=0)
print(image.shape, type(image))
print(image.max(), image.min()) 
image2 = image/255. # rescale pixel value between: 0 --> 1
print(image2.max(), image2.min())
print(image2.shape)

# Prediction for IoU
y_pred = model.predict(image2)
y_pred_thres = y_pred > 0.5

# IoU calculations

n_classes = 2    # 0 and 1 leaf or not leaf 
iou_keras2 = MeanIoU(num_classes=n_classes)
iou_keras2.update_state(y_pred, y_pred_thres)
print("mean iou = ", iou_keras2.result().numpy())

# prediction for test image

prediction = (model.predict(image2)[0,:,:,0] > 0.5).astype(np.uint8)

plt.figure(figsize=(16, 8))

plt.subplot(231)
plt.title('Testing Image')
plt.imshow(img)

plt.subplot(232)
plt.title('Prediction on test image')
plt.imshow(prediction, cmap='gray')

filename = 'prediction_mask.jpg'
plt.imsave(filename,prediction)

# Calculating IoU
n_classes = 2    # 0 and 1 leaf or not leaf 
iou_keras2 = MeanIoU(num_classes=n_classes)
iou_keras2.update_state(prediction, y_pred_thres)
print("mean iou = ", iou_keras2.result().numpy())

# Find all pixels that are nonzero (will be our coordinates)
coord = cv2.findNonZero(prediction)

# Check shape
print(coord.shape)

# Reshape coord
points = np.array(coord).reshape(coord.shape[0],2)

# Check new shape
print(points.shape)

# Plot original image with all points 

plt.imshow(img)
plt.plot(markersize=10)  # og:shorthand for green circle
plt.scatter(points[:, 0], points[:, 1], marker=".", color="forestgreen", s=2)
plt.xticks([])
plt.yticks([])
plt.savefig('green_mask.png', bbox_inches='tight')
plt.show()

# Mask original image with all coords + making all background black

leaf = cv2.imread("/content/6.JPG")
cv2_imshow(leaf)

# Mask original image with all coords + making all background black

mask = np.zeros(leaf.shape).astype(leaf.dtype)   # create mask containing zeros
color = [255, 255, 255]                          # set color for mask
cv2.fillPoly(mask, pts=[points],color=color)     # fill mask where based on our extracted coordinates 

result = cv2.bitwise_and(leaf, mask)             # our final filterd image!!
cv2.imwrite("result.jpg", result)                # save image

# plot results comaperd with mask and original image

plt.figure(figsize=(16, 8))

plt.subplot(231)
plt.title('Original Image')
plt.imshow(img)

plt.subplot(232)
plt.title('Final Result')
plt.imshow(result)

plt.subplot(233)
plt.title('Mask')
plt.imshow(mask)

cv2_imshow(result)







